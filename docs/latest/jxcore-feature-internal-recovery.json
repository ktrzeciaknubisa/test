{
  "source": "doc/api/jxcore-feature-internal-recovery.markdown",
  "modules": [
    {
      "textRaw": "Internal Recovery",
      "name": "internal_recovery",
      "desc": "<p>In addition to recovering the process of a crashed applications by external <a href=\"jxcore-command-monitor.html\">monitoring process</a>,\nJXcore also provides automatic Internal Process Recovery as well as Internal Thread Recovery (for code running in multi-threaded mode).\n\n</p>\n",
      "modules": [
        {
          "textRaw": "Internal Process Recovery",
          "name": "internal_process_recovery",
          "desc": "<p>Internal Process Recovery  can be enabled by attaching any callback to <code>restart</code> event <strong>inside a main thread</strong>.\nWhen an exception occurs inside the application, the callback is invoked and you can decide if to allow restart of the entire process or not.\nAlso, this is a good opportunity to save some data used by the application, which would otherwise be lost after the crash.\n\n</p>\n<pre><code class=\"js\">process.on(&#39;restart&#39;, function (restartCallback, newExitCode) {\n    // do whatever you want before application&#39;s crash\n    // and when you&#39;re done - call the callback to restart the process\n    restartCallback();\n});</code></pre>\n<p>Arguments for the callback:\n\n</p>\n<ul>\n<li><code>restartCallback</code> {Function}<ul>\n<li><code>newExitCode</code> {Number}</li>\n</ul>\n</li>\n<li><code>currentExitCode</code> {Number}</li>\n</ul>\n<p>The <code>restartCallback</code> is a function, which should be invoked if you want to allow for application restart/recovery.\nUnless it&#39;s used, the process will exit (after all it has just crashed) without restart.\n\n</p>\n<p>Any tasks like saving application&#39;s data (objects, variables etc) into database, must be done before calling <code>restartCallback</code>.\n\n</p>\n<p>When invoking this callback, you can pass an <code>newExitCode</code>, that you want the application&#39;s process to be restarted with.\nCurrent process will exit with this code and the application will be relaunched as a new process.\n<code>newExitCode</code> for the callback is optional. When omitted, the current application&#39;s exit code will be used.\n\n</p>\n<p><code>currentExitCode</code> - holds current exit code of the application, which is just about to crash.\n\n</p>\n<p>In the example below we are throwing an exception, which causes <code>restart</code> event to be fired. Just before the restart, we&#39;re adding new parameter to <code>process.argv</code>, and this is the way to pass an argument to the new process.\nWe do this in order to prevent circular recoveries.\n\n</p>\n<p>The code should be launched as single-threaded (without <code>mt</code>/<code>mt-keep</code> parameter), because it handles the recovery of the main process:\n\n</p>\n<pre><code>&gt; jx sample.js</code></pre>\n<p>sample.js:\n\n</p>\n<pre><code class=\"js\">process.on(&#39;restart&#39;, function (restartCallback, newExitCode) {\n\n    //in order to prevent circular recoveries only recover once!\n    if (process.argv[process.argv.length - 1] != &quot;111&quot;) {\n        process.argv[process.argv.length] = 111;\n\n        console.log(&quot;Restarting&quot;);\n        //calling restartCB\n        restartCallback(123);\n    }\n    else {\n        // we&#39;re not calling restartCallback(), so the application will exit\n        // without restarting\n        console.log(&quot;Skipping restart.&quot;);\n    }\n});\n\n\n// JXcore does not auto-restart application if it dies under 5000 ms\nsetTimeout(function () {\n    throw &quot;&quot;;\n}, 5200);</code></pre>\n<p>There are two situations, when Internal Process Recovery is not performed:\n\n</p>\n<ol>\n<li>Application was alive for less than 5000 milliseconds. This value will be configurable in the future, but for now it&#39;s a constant.</li>\n<li>When any listener is attached to <code>process.on(&quot;uncaughtException&quot;)</code> event, the thread recovery is not active.\nIt makes sense only for uncaught exceptions, which in this case are actually caught by <code>uncaughtException</code> event.</li>\n</ol>\n",
          "type": "module",
          "displayName": "Internal Process Recovery"
        },
        {
          "textRaw": "Internal Thread Recovery",
          "name": "internal_thread_recovery",
          "desc": "<p>This is analogous to <a href=\"#internal_process_recovery\">Internal Process Recovery</a>, except that it concerns a <strong>single thread</strong> rather than entire application process.\n\n</p>\n<p>Attaching any callback to this event inside a code running in a subthread enables internal thread recovery.\nWhen an exception occurs inside the subthread, the callback is invoked. You can then decide to allow restart of the thread or not.\nAlso this is a good opportunity to save some data used by this thread which would otherwise be lost after the crash.\n\n</p>\n<pre><code class=\"js\">process.on(&#39;restart&#39;, function (restartCallback) {\n    // do whatever you want before thread&#39;s crash\n    // and when you&#39;re done - call the callback to restart the thread\n    restartCallback();\n});</code></pre>\n<p>Argument for the callback:\n\n</p>\n<ul>\n<li><code>restartCallback</code> {Function}</li>\n</ul>\n<p>This function should be invoked to allow for thread recovery. Unless it is called, the thread will die without restart.\nAny tasks, like saving some thread&#39;s data (objects, variables etc) into database or even shared memory store, must be done before calling <code>restartCallback</code>.\n\n</p>\n<p>In the example below we are throwing an exception, which causes restart event to be fired.\nAlso we are counting how many times the thread was restarted. Based on that value we decide when to stop.\n\n</p>\n<p>The code should be run with mt-keep parameter:\n\n</p>\n<pre><code>&gt; jx mt-keep sample.js</code></pre>\n<p>sample.js:\n\n</p>\n<pre><code class=\"js\">var shared = jxcore.store.shared;\nvar sid = &quot;threadRestartCount_&quot; + process.threadId;\n\nvar counter = 0;\n\n// this is just for storing thread&#39;s restart counter.\n// we use jxcore.store.shared here, because it is static (unrelated to the threads)\nif (shared.exists(sid)) {\n    counter = parseInt(shared.get(sid)) + 1;\n    console.log(&quot;Thread no %s restarted %d times.&quot;, process.threadId, counter);\n}\nshared.set(sid, counter);\n\n// attaching callback to this event enables the thread recovery,\n// but still you need to call restartCallback() explicitly to make a restart\nprocess.on(&#39;restart&#39;, function (restartCallback) {\n    if (counter &lt; 3) {\n        // we don&#39;t want to allow for infinitive restarts. 3 is enough.\n        console.log(&quot;Restarting thread no &quot; + process.threadId);\n        restartCallback();\n    } else {\n        console.log(&quot;Thread no %s was restarted %d times. We&#39;ll not restart any more.&quot;,\n            process.threadId, counter);\n        // releasing the thread allows main process to exit,\n        // when all the threads are released.\n        process.release();\n    }\n});\n\n// this loop is used to throw an exception inside a subthread\nsetTimeout(function () {\n    throw &quot;Let&#39;s restart the thread!&quot;;\n}, 100 * counter * process.threadId);</code></pre>\n<p>Please note, that when any listener is attached to <code>process.on(&quot;uncaughtException&quot;)</code> event, the thread recovery is not active, because it makes sense only for uncaught exceptions, which in this case are actually caught by <code>uncaughtException</code> event.\n\n</p>\n",
          "type": "module",
          "displayName": "Internal Thread Recovery"
        }
      ],
      "type": "module",
      "displayName": "Internal Recovery"
    },
    {
      "textRaw": "Internal Recovery vs Process Monitor",
      "name": "internal_recovery_vs_process_monitor",
      "desc": "<p>Process Monitor and Internal Process Recovery should not be used simultaneously. Both of them perform restart of the application&#39;s process,\nso they could interfere with each other leading to an unexpected behavior.\nFor example, the application could be respawned into multiple instances, or fall into uncontrolled loop of restarting.\n\n</p>\n<p>On the other hand, when your application is running in multi-threaded mode, you can still use Internal Thread Recovery\n(which allows to restart crashed threads, not the application&#39;s process) together with Process Monitor.\n</p>\n",
      "type": "module",
      "displayName": "Internal Recovery vs Process Monitor"
    }
  ]
}
